"use strict";(self.webpackChunkdagger=self.webpackChunkdagger||[]).push([[6886],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>g});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),c=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(a),m=n,g=p["".concat(l,".").concat(m)]||p[m]||d[m]||o;return a?r.createElement(g,i(i({ref:t},u),{},{components:a})):r.createElement(g,i({ref:t},u))}));function g(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:n,i[1]=s;for(var c=2;c<o;c++)i[c]=a[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},4730:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=a(7462),n=(a(7294),a(3905));const o={},i="Architecture",s={unversionedId:"concepts/architecture",id:"concepts/architecture",isDocsHomePage:!1,title:"Architecture",description:"Dagger or Data Aggregator is a cloud native framework built on top of Apache Flink for stateful processing of data.",source:"@site/docs/concepts/architecture.md",sourceDirName:"concepts",slug:"/concepts/architecture",permalink:"/dagger/docs/concepts/architecture",editUrl:"https://github.com/raystack/dagger/edit/master/docs/docs/concepts/architecture.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Lifecycle",permalink:"/dagger/docs/concepts/lifecycle"},next:{title:"Overview",permalink:"/dagger/docs/advance/overview"}},l=[{value:"System Design",id:"system-design",children:[{value:"Components",id:"components",children:[]},{value:"Schema Handling",id:"schema-handling",children:[]}]},{value:"Dagger Integration",id:"dagger-integration",children:[{value:"Dagger Source",id:"dagger-source",children:[]},{value:"ProtoDescriptors",id:"protodescriptors",children:[]},{value:"Flink Job Manager",id:"flink-job-manager",children:[]},{value:"Flink Task Manager",id:"flink-task-manager",children:[]},{value:"Zookeeper",id:"zookeeper",children:[]},{value:"Object Store",id:"object-store",children:[]},{value:"Metrics Reporter",id:"metrics-reporter",children:[]},{value:"Sink",id:"sink",children:[]}]}],c={toc:l},u="wrapper";function p(e){let{components:t,...o}=e;return(0,n.kt)(u,(0,r.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"architecture"},"Architecture"),(0,n.kt)("p",null,"Dagger or Data Aggregator is a cloud native framework built on top of Apache Flink for stateful processing of data."),(0,n.kt)("h2",{id:"system-design"},"System Design"),(0,n.kt)("h3",{id:"components"},"Components"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Dagger Architecture",src:a(6605).Z})),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},(0,n.kt)("strong",{parentName:"em"},"Stream"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"A Stream defines a logical grouping of a data source and its associated ",(0,n.kt)("a",{parentName:"li",href:"https://developers.google.com/protocol-buffers"},(0,n.kt)("inlineCode",{parentName:"a"},"protobuf")),"\nschema. All data produced by a source follows the protobuf schema. The source can be an unbounded one such as\n",(0,n.kt)("inlineCode",{parentName:"li"},"KAFKA_SOURCE")," or ",(0,n.kt)("inlineCode",{parentName:"li"},"KAFKA_CONSUMER")," in which case, a single stream can consume from one or more topics all sharing the\nsame schema. Otherwise, the source can be a bounded one such as ",(0,n.kt)("inlineCode",{parentName:"li"},"PARQUET_SOURCE")," in which case, one or more parquet\nfiles as provided are consumed in a single stream."),(0,n.kt)("li",{parentName:"ul"},"Dagger can support multiple streams at a time."),(0,n.kt)("li",{parentName:"ul"},"For a kafka based source, many Kafka consumer-level configurations like consumer groups and auto offset reset can be set in the stream itself.")),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},(0,n.kt)("strong",{parentName:"em"},"Dagger Core"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The core part of the dagger(StreamManager) has the following responsibilities. It works sort of as a controller for other components in the dagger.",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Configuration management."),(0,n.kt)("li",{parentName:"ul"},"Table registration."),(0,n.kt)("li",{parentName:"ul"},"Configuring Deserialization and Serialization of data."),(0,n.kt)("li",{parentName:"ul"},"Manage execution of other plugins like pre and post processors."),(0,n.kt)("li",{parentName:"ul"},"User-Defined functions registration.")))),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},(0,n.kt)("strong",{parentName:"em"},"Pre-Processor"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Each stream registered on daggers can have chained pre-processors. They will run and transform the table before registering it for SQL."),(0,n.kt)("li",{parentName:"ul"},"Currently, only ",(0,n.kt)("a",{parentName:"li",href:"/dagger/docs/guides/use_transformer"},"transformers")," are supported as part of the pre-processor. Pre-processor are simply Flink's ProcessFunctions/Operators which can transform the input stream to another stream of data prior to execution of SQL. They are ideal for complex filtration logic.")),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},(0,n.kt)("strong",{parentName:"em"},"SQL Execution"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Dagger uses Flink's native SQL Planner to executed SQL(The more powerful Blink Planner will be supported in the next releases)."),(0,n.kt)("li",{parentName:"ul"},"In this layer dagger executes streaming SQL (similar to ANSI SQL) on registered unbounded DataStream(s). Flink uses apache calcite for SQL execution."),(0,n.kt)("li",{parentName:"ul"},"In case you have registered any ",(0,n.kt)("a",{parentName:"li",href:"/dagger/docs/guides/use_udf"},"UDF"),", SQL engines picks them up and lets you use them in your defined SQL query.")),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},(0,n.kt)("strong",{parentName:"em"},"Type Handler"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Type Handler handles the SerDe mechanism for raw source data to Flink understandable Distributed Data format(Flink Row)."),(0,n.kt)("li",{parentName:"ul"},"It recursively parses Source specific messages to Flink Row on the consumer side and Flink row to sink specific\nmessages on the producer side."),(0,n.kt)("li",{parentName:"ul"},"Dagger supports serialization and deserialization of various data types ranging from primitives such as int, long, float, etc to\ncomplex types such as maps, nested messages, repeated types, etc.")),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},(0,n.kt)("strong",{parentName:"em"},"Post-Processor"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Post-processors are similar to pre-processors but are rich in functionalities."),(0,n.kt)("li",{parentName:"ul"},"They also enable async processing from external Data source/Service endpoints over network calls and complex transformation beyond SQL."),(0,n.kt)("li",{parentName:"ul"},"They use some of the advanced Flink functionalities like RichFunctions and RichAsyncFunction as the building block. User can define a JSON based DSL to interact with them."),(0,n.kt)("li",{parentName:"ul"},"Some of the supported types of post processors are",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"/dagger/docs/advance/post_processor#external-post-processor"},"External Post-Processors")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"/dagger/docs/advance/longbow"},"Longbow")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"/dagger/docs/advance/post_processor#internal-post-processor"},"Internal Post-Processors")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"/dagger/docs/guides/use_transformer"},"Transformers"))))),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},(0,n.kt)("strong",{parentName:"em"},"Telemetry Processor"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"For a distributed streaming engine like Dagger, it becomes really essential to collect and report all the essential application-level metrics. The Telemetry Processor is responsible to do so."),(0,n.kt)("li",{parentName:"ul"},"In its core Telemetry Processor is another type of post-processor which internally use pub-sub to collect application metrics."),(0,n.kt)("li",{parentName:"ul"},"After the metrics are collected they need to be sent to some external systems. Metrics reporter which is a library in the Flink cluster does this. Follow ",(0,n.kt)("a",{parentName:"li",href:"https://ci.apache.org/projects/flink/flink-docs-release-1.9/monitoring/metrics.html"},"this")," for more detailed information about flink metrics.")),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},(0,n.kt)("strong",{parentName:"em"},"Sink and Serializer"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"After the data is processed and results are materialized they need to be sinked to some external persistent storage."),(0,n.kt)("li",{parentName:"ul"},"Dagger supports Kafka, BigQuery and InfluxDB as supported sinks where the unbounded results are pushed at the end of the lifecycle."),(0,n.kt)("li",{parentName:"ul"},"In the case of Kafka Sink the final result is protobuf encoded. So the result goes through a serialization stage on some defined output schema. The serializer module of the proto-handler does this. Results in Kafka can be used via any Kafka consumer."),(0,n.kt)("li",{parentName:"ul"},"Influx Sink helps in real-time analytics and dashboarding. In the case of Influx Sink dagger, converts results in Flink Row to InfluxDB points and add ",(0,n.kt)("inlineCode",{parentName:"li"},"tag"),"/",(0,n.kt)("inlineCode",{parentName:"li"},"labels")," as specified in the SQL."),(0,n.kt)("li",{parentName:"ul"},"BigQuery is a data warehouse capable of running SQL queries over large datasets. Bigquery Sink is created using the ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/raystack/depot/tree/main/docs"},"Raystack Depot")," library. Depot is a sink connector, which acts as a bridge between data processing systems and real sink. In BigQuery Sink, each Flink Row is converted into one BigQuery table row. The schema, table and partitioning details of the table are fetched from user supplied configuration.")),(0,n.kt)("h3",{id:"schema-handling"},"Schema Handling"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Protocol buffers are Google's language-neutral, platform-neutral, extensible mechanism for serializing structured data.\nEach stream, irrespective of the data source, should produce data according to a fixed, configured protobuf schema."),(0,n.kt)("li",{parentName:"ul"},"Dagger deserializes the data consumed from the topics using the Protobuf descriptors generated out of the artifacts.\nThe schema handling i:e, finding the mapped schema for the topic, downloading the descriptors, and dynamically being\nnotified of/updating with the latest schema is abstracted through a homegrown library called ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/raystack/stencil"},"stencil"),"."),(0,n.kt)("li",{parentName:"ul"},"Stencil is a proprietary library that provides an abstraction layer, for schema handling."),(0,n.kt)("li",{parentName:"ul"},"Schema Caching, dynamic schema updates are features of the stencil client library.")),(0,n.kt)("h2",{id:"dagger-integration"},"Dagger Integration"),(0,n.kt)("h3",{id:"dagger-source"},"Dagger Source"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The Data source configuration used by Dagger to generate streaming data. This can be either\n",(0,n.kt)("a",{parentName:"li",href:"/dagger/docs/reference/configuration#sample-streams-configuration-using-kafka_consumer-as-the-data-source-"},"Kafka")," based or\n",(0,n.kt)("a",{parentName:"li",href:"/dagger/docs/reference/configuration#sample-streams-configuration-using-parquet_source-as-the-data-source-"},"Parquet files"),". Check\n",(0,n.kt)("a",{parentName:"li",href:"/dagger/docs/guides/choose_source"},"here")," for more details about Dagger Sources.")),(0,n.kt)("h3",{id:"protodescriptors"},"ProtoDescriptors"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Generated protobuf descriptors which are hosted behind an artifactory/HTTP endpoint. This endpoint URL and the proto that the dagger deployment should use to deserialize data can be configured.")),(0,n.kt)("h3",{id:"flink-job-manager"},"Flink Job Manager"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"JobManager is the JVM process that acts as the brain of Flink's execution life cycle. Handles SQL execution, Job Graph creation, Coordinate Task Managers, Snapshotting and many other critical operations for distributed stream processing.")),(0,n.kt)("h3",{id:"flink-task-manager"},"Flink Task Manager"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Taskmanagers (TM) are the JVM processes which are actually responsible for parallel stateful stream processing of unbounded data. Taskslots are single threads inside Flink's Taskmanager that process single operators in the job graph.")),(0,n.kt)("h3",{id:"zookeeper"},"Zookeeper"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Flink leverages ZooKeeper for distributed coordination between all running JobManager instances. ZooKeeper is a separate service from Flink, which provides highly reliable distributed coordination via leader election and lightweight consistent state storage.")),(0,n.kt)("h3",{id:"object-store"},"Object Store"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Operators in Flink can be stateful. In order to make state fault-tolerant, Flink needs to checkpoint the state in some sort of distributed persistent object stores like s3/GCS/HDFS. Checkpoints allow Flink to recover state and positions in the streams to give the application the same semantics as a failure-free execution.")),(0,n.kt)("h3",{id:"metrics-reporter"},"Metrics Reporter"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Metrics reporter sends the application metrics to some other external systems optimised for metrics data. Metrics reporters can be configured at the cluster level.")),(0,n.kt)("h3",{id:"sink"},"Sink"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"InfluxDB - time-series database for real-time analytics."),(0,n.kt)("li",{parentName:"ul"},"Kafka - Replayable queue to easy use of generated results."),(0,n.kt)("li",{parentName:"ul"},"BigQuery - data warehouse capable of running SQL queries over large datasets.")))}p.isMDXComponent=!0},6605:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/dagger_system_design-2dcd3bec859898184c7e65fb9b1a4827.png"}}]);