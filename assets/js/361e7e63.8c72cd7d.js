"use strict";(self.webpackChunkdagger=self.webpackChunkdagger||[]).push([[8565],{3905:(e,t,i)=>{i.d(t,{Zo:()=>d,kt:()=>m});var n=i(7294);function r(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function a(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function s(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?a(Object(i),!0).forEach((function(t){r(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function o(e,t){if(null==e)return{};var i,n,r=function(e,t){if(null==e)return{};var i,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||(r[i]=e[i]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(r[i]=e[i])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),i=t;return e&&(i="function"==typeof e?e(t):s(s({},t),e)),i},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var i=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=c(i),m=r,g=u["".concat(l,".").concat(m)]||u[m]||p[m]||a;return i?n.createElement(g,s(s({ref:t},d),{},{components:i})):n.createElement(g,s({ref:t},d))}));function m(e,t){var i=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=i.length,s=new Array(a);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var c=2;c<a;c++)s[c]=i[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,i)}u.displayName="MDXCreateElement"},4226:(e,t,i)=>{i.r(t),i.d(t,{contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var n=i(7462),r=(i(7294),i(3905));const a={},s="Basics",o={unversionedId:"concepts/basics",id:"concepts/basics",isDocsHomePage:!1,title:"Basics",description:"For Stream processing and hence for dagger user must know about some basic concepts and terminologies before using it. Listing some of the important terms and keywords related to dagger/stream processing which will solidify your understanding and help you get started with Dagger.",source:"@site/docs/concepts/basics.md",sourceDirName:"concepts",slug:"/concepts/basics",permalink:"/dagger/docs/concepts/basics",editUrl:"https://github.com/odpf/dagger/edit/master/docs/docs/concepts/basics.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Overview",permalink:"/dagger/docs/concepts/overview"},next:{title:"Lifecycle",permalink:"/dagger/docs/concepts/lifecycle"}},l=[{value:"Terminologies",id:"terminologies",children:[{value:"Stream Processing",id:"stream-processing",children:[]},{value:"Streams",id:"streams",children:[]},{value:"Apache Flink",id:"apache-flink",children:[]},{value:"Time Series Database",id:"time-series-database",children:[]},{value:"Protobuf",id:"protobuf",children:[]},{value:"Parallelism",id:"parallelism",children:[]},{value:"Dagger Queries",id:"dagger-queries",children:[]},{value:"Function",id:"function",children:[]},{value:"User Defined Functions(UDF)",id:"user-defined-functionsudf",children:[]},{value:"Windowing",id:"windowing",children:[]},{value:"Rowtime",id:"rowtime",children:[]}]}],c={toc:l};function d(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"basics"},"Basics"),(0,r.kt)("p",null,"For Stream processing and hence for dagger user must know about some basic concepts and terminologies before using it. Listing some of the important terms and keywords related to dagger/stream processing which will solidify your understanding and help you get started with Dagger."),(0,r.kt)("h2",{id:"terminologies"},"Terminologies"),(0,r.kt)("h3",{id:"stream-processing"},"Stream Processing"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Stream processing")," commonly known as ",(0,r.kt)("inlineCode",{parentName:"p"},"Real-Time processing")," lets users process and query a series of data at the same\ntime as it is being produced. The source that is producing this data can either be a bounded source such as Parquet Files\nor an unbounded source such as Kafka."),(0,r.kt)("h3",{id:"streams"},"Streams"),(0,r.kt)("p",null,"A Stream defines a logical grouping of a data source and its associated ",(0,r.kt)("a",{parentName:"p",href:"https://developers.google.com/protocol-buffers"},(0,r.kt)("inlineCode",{parentName:"a"},"protobuf")),"\nschema. All data produced by a source follows the protobuf schema. The source can be an unbounded one such as\n",(0,r.kt)("inlineCode",{parentName:"p"},"KAFKA_SOURCE")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"KAFKA_CONSUMER")," in which case, a single stream can consume from one or more topics all sharing the\nsame schema. Otherwise, the source can be a bounded one such as ",(0,r.kt)("inlineCode",{parentName:"p"},"PARQUET_SOURCE")," in which case, one or more parquet\nfiles as provided are consumed in a single stream."),(0,r.kt)("p",null,"Dagger allows creation of multiple streams, each having its own different schema, for use-cases such as SQL joins. However, the SQL\nqueries become more complex as the number of streams increase."),(0,r.kt)("h3",{id:"apache-flink"},"Apache Flink"),(0,r.kt)("p",null,"Apache Flink is a framework and distributed processing engine for processing over unbounded and bounded data streams. Flink works as the underlying layer of Dagger. Find more information about Flink ",(0,r.kt)("a",{parentName:"p",href:"https://flink.apache.org/"},"here"),"."),(0,r.kt)("h3",{id:"time-series-database"},"Time Series Database"),(0,r.kt)("p",null,"A time-series database ",(0,r.kt)("a",{parentName:"p",href:"https://www.influxdata.com/time-series-database/"},"(TSDB)")," is a database optimized for time-stamped or time-series data. Time series data are simply measurements or events that are tracked, monitored, down-sampled, and aggregated over time. Dagger platform used InfluxDB, a Time Series Database as one of its sink for Analytical use cases."),(0,r.kt)("h3",{id:"protobuf"},"Protobuf"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://developers.google.com/protocol-buffers"},"Protocol buffer or Protobuf")," is a serialization mechanism for structured data. It\u2019s\nwell optimized to be transferred via the network. Dagger supports processing Data which is in Protobuf format."),(0,r.kt)("h3",{id:"parallelism"},"Parallelism"),(0,r.kt)("p",null,"Dagger uses Flink for Distributed Data processing in scale. ",(0,r.kt)("a",{parentName:"p",href:"https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/parallel.html"},"Slots/Parallelism")," is the Flink\u2019s unit for Parallel Processing Data which provides an efficient way to horizontally scale up your job."),(0,r.kt)("h3",{id:"dagger-queries"},"Dagger Queries"),(0,r.kt)("p",null,"Dagger supports Streaming SQL support on streams which we call Dagger Queries. These queries are similar to standard ANSI SQL with some more additional syntax."),(0,r.kt)("h3",{id:"function"},"Function"),(0,r.kt)("p",null,"Dagger supports some SQL functions out of the box to be used in the queries. Most Apache Calcite supported functions are supported in Dagger with the exceptions of some functions. Flink also supports some generic functions."),(0,r.kt)("h3",{id:"user-defined-functionsudf"},"User Defined Functions(UDF)"),(0,r.kt)("p",null,"If Calcite and Flink do not support your desired function, it is pretty easy to expose new custom functions to Dagger which we call User Defined Functions. ",(0,r.kt)("a",{parentName:"p",href:"/dagger/docs/reference/udfs"},"List of supported UDFs")," in Dagger."),(0,r.kt)("h3",{id:"windowing"},"Windowing"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://flink.apache.org/news/2015/12/04/Introducing-windows.html"},"Time Windows")," are at the heart of processing infinite streams. As Data being ingested to streams are unbounded and infinite, time windows provide a mechanism to split the stream into \u201cbuckets\u201d of finite size, over which we can apply computations."),(0,r.kt)("p",null,"Dagger provides two different types of windows"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Hop/Tumbling Windows"),(0,r.kt)("p",{parentName:"li"},"Each element to a window of specified window size. Tumbling windows have a fixed size and do not overlap. For example, if you specify a tumbling window with a size of 5 minutes, the current window will be evaluated and a new window will be started every five minutes as illustrated by the following figure. (image credit: ",(0,r.kt)("a",{parentName:"p",href:"https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/stream/operators/windows.html"},"Flink Operators"),")\n",(0,r.kt)("img",{alt:"Tumble Window",src:i(4595).Z}))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Sliding Windows"),(0,r.kt)("p",{parentName:"li"},"Each element gets assigned to windows of fixed length. An additional window slide parameter controls how frequently a sliding window is started. Hence, sliding windows can be overlapping if the slide is smaller than the window size. In this case, elements are assigned to multiple windows. (image credit: ",(0,r.kt)("a",{parentName:"p",href:"https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/stream/operators/windows.html"},"Flink Operators"),")\n",(0,r.kt)("img",{alt:"Sliding Window",src:i(9742).Z})))),(0,r.kt)("h3",{id:"rowtime"},"Rowtime"),(0,r.kt)("p",null,"Rowtime is the time attribute field in your Data streams on which you can run your time windowed aggregations. You can configure this while creating a Dagger. Rowtime is the one of the time definition fields in input schema on which Dagger does all time it's time-base Operations. Read ",(0,r.kt)("a",{parentName:"p",href:"https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/dev/table/streaming/time_attributes.html"},"here")," on time attributes."))}d.isMDXComponent=!0},9742:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/sliding-b18de094a27e079827e5391ec5515e35.png"},4595:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/tumble-bb067c45e6b17f079b8a23e8bb82a6ae.png"}}]);